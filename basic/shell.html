<?php

/**
     Shell 基础

     shell 概述
     脚本执行方式
     bash 的基本功能

     shell 是什么
     shell 是一个命令行解释器 它们用户提供了一个向 linux 内核发送请求以便运行程序的界面系统级程序 用户可以用 shell 来启动 挂起 停止甚至是编写一些程序
     shell 还是一个功能相当强大的编程语言 易编写 易调试 灵活性较强 shell 是解释执行的脚本语言 在 shell 中可以直接调用 linux 系统命令

     shell 的分类
     bourne shell 从 1979 起 unix 就开始使用 bourne shell bourne shell 的主文件名为sh

     c shell 主要在 BSD 版的 Unix 系统中使用 其语法和 c 语言相类似而得名

     shell 的两种主要语法类型有 bourne 和 c 这两种语法彼此不兼容 
     bourne 家庭主要包括 sh ksh bash psh zsh
     c 家族主要包括 csh tcsh

     bash bash 与 sh 兼容 现在使用 linux 就是使用 bash 作为用户的基本 shell

     echo 输出命令
     echo [选项] [输出内容]
     -e 支持反斜线控制的字符转换

     \a 输出警告音
     \b 退格键 也就是向左删除键
     \n 换行符
     \r 回车键
     \t 制表符 也就是 Tab 键
     \v 垂直制表符
     \Onnn 按照八进制 ASCII 码表输出字符 其中 0 为数字零 nnn 是三位八进制数
     \xhh  按照十六进制 ASCII 码表输出字符 其中 hh 是两位十六朝进制数

     [root@localhost ~]# echo -e "\e[1;31m \e[0m";
     #\e[1;开启颜色输出 \e[0m 关闭 输出颜色 30m=黑色 31m=红色 32m=绿色 33m=黄色 34m=蓝色 35m=洋红 36m=青色 37m=白色

     第一个脚本
     [root@localhost sh]# vi hello.sh
     #!/bin/bash
     #The first program

     脚本执行
     赋予执行权限 直接运行
     chmod 755 hello.sh #如果不给权限会提示 permission denied
     ./hello.sh
     能过 bash 调用执行脚本
     bash hello.sh

     bash 的基本功能
     什么是别名
     命令别名 == 人的小名
     别名永久生效与删除别名
     vi ~/.bashrc #写入环境变量配置文件
     unalias 别名 #删除别名

     常用快捷键
     ctrl + c 强制终止当前命令
     ctrl + l 清屏
     ctrl + a 光标移到命令行首
     ctrl + e 光标移到命令行尾
     ctrl + u 从光标所在位置删除到行首
     ctrl + z 把命令放入后台
     ctrl + r 在历史命令中搜索

     历史命令
     history [选项] [历史命令保存文件]
     -c 清空历史命令
     -w 把缓存中的历史命令写入历史命令保存文件 ~/.bash_history

     历史命令的调用
     使用上下箭头调用以前的历史命令
     使用 "!n" 重复执行第 n 条历史命令
     使用 "!!" 重复执行上一条命令
     使用 "!字串" 重复执行最后一条以该字串开头的命令

     命令与文件补全
     在 bash 中 命令与文件补全是非常方便与常用的功能 我们只要在输入命令或文件时 按 "Tab" 键就会自动进行补全

     标准输入输出
     设备   设备文件名   文件描述符 类型
     键盘   /dev/stdin   0          标准输入
     显示器 /dev/sdtout  1          标准输出
     显示器 /dev/sdterr  2          标准错误输出

     输出重定向
     标准输出重定向 
     命令 > 文件 以覆盖的方式 把命令的正确输出 输出到指定的文件或设备当中
     命令 >> 文件 以追加的方式 把命令的正确输出 输出到指定的文件或设备当中
     标准错误输出重定向
     错误命令 2>文件 以覆盖的方式 把命令的错误输出 输出到指定的文件或设备当中
     错误命令 2>>文件 以追加的方式 把命令的错误输出 输出到指定的文件或设备当中
     正确输出和错误输出同时保存
     命令 > 文件 2>&1 输出都保存到同一个文件当中
     命令 >> 文件 2>&1 以追加的方式 把正确输出和错误输出都保存到同一个文件当中
     命令 &> 文件 以覆盖的方式 把正确输出和错误输出都保存到同一个文件当中
     命令 &>> 文件 以追加的方式 把正确输出和错误输出都保存到同一个文件当中
     命令 >> 文件1 2>>文件2 把正确的输出追加到文件1中 把错误的输出追加到文件2 中

     输入重定向
     [root@localhost ~]# wc [选项][文件名]
     -c 统计字节数
     -w 统计单词数
     -l 统计行数
     命令 < 文件把文件作为命令的输入
     命令 << 标识符
     标识符把标识符之间内容作为命令的输入

     多命令顺序执行
     : 命令1:命令2 多个命令顺序执行 命令之间没有
     && 命令1&&命令2 逻辑与 当命令1正确执行 则命令2才会执行 当命令1执行不正确 则命令2不会执行
     || 命令1||命令2 逻辑或 当命令1执行不正确 则命令2才会执行 当命令1正确执行 则命令2不会执行
     [root@localhost ~]# pwd; touch abc; ls; date
     [root@localhost ~]# ls anaconda-ks.cfg && echo yes
     [root@localhost ~]# ls anaconda-ks.cfg || echo no
     [root@localhost ~]# 命令 && echo yes || echo no

     管道符
     [root@localhost ~]# 命令1 | 命令2 #命令1的正确输出作为命令2的操作对象
     [root@localhost ~]# netstat -an | grep ESTABLISHED
     [root@localhost ~]# netstat -an | grep ESTABLISHED | wc -l

     通配符
     ? 匹配一个任意字符
     * 匹配0个或任意多个任意字符
     [] 匹配中括号中任意一个字符 例如: [abc] 代表一定匹配一个字符 或者是a 或者是b 或者说是c
     [-] 匹配中括号中任意一个字符 -代表一个范围 例如 [a-z] 代表匹配一个小写字母
     [^] 逻辑非 表示匹配不是中括号内的一个字符 例如 [^0-9] 代表匹配一个不是数字的字符

     bash 中其他特殊符号
     '' 单引号 在单引号中所有的特殊符号 如 "$" 和 "`" (反引号) 都没有特殊含义
     "" 双引号 在双引号中特殊符号都没有特殊含义 但是 "$" "`" "\" 是例外 拥有 "调用变量的值" "引用命令" 和 "转义符" 的特殊含义
     `  反引号 反引号括起来的内容是系统命令 在 bash 中会先执行它 和 $() 作用一样 不过推荐使用 $() 因为反引号非常容易看错
     $() 和反引号作用一样 用来引用系统命令
     # 用于调用变量的值 如需要调用变量 name 的值时 需要用 $name 的方式得到变量的值
     \ 转义符号 跟在 \ 之后的特殊符号将推动特殊含义 变为普通字符 如\$将输出 "$" 符号 而不当做是变量引用
*/